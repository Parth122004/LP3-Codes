#include <iostream>     // For input/output operations
#include <vector>       // For using dynamic array (vector)
#include <cstdlib>      // For rand() and srand()
#include <ctime>        // For time() to generate random seed
using namespace std;

//-------------------- CLASS DEFINITION --------------------
class QuickSort {
public:

    // Partition function using the last element as pivot
    int partition(vector<int>& a, int low, int high) {
        int pivot = a[high];       // Choose last element as pivot
        int i = low - 1;           // Index of smaller element

        // Rearrange elements: smaller than pivot to left, larger to right
        for (int j = low; j < high; j++) {
            if (a[j] < pivot) {
                swap(a[++i], a[j]); // Place smaller element before pivot
            }
        }

        // Place pivot at correct sorted position
        swap(a[i + 1], a[high]);
        return i + 1;              // Return pivot index
    }

    // ---------------- Deterministic Quick Sort ----------------
    void quickSortDet(vector<int>& a, int low, int high) {
        if (low < high) {                     // Base case check
            int pi = partition(a, low, high); // Partition the array
            quickSortDet(a, low, pi - 1);     // Sort left half
            quickSortDet(a, pi + 1, high);    // Sort right half
        }
    }

    // ---------------- Randomized Partition ----------------
    int randomPartition(vector<int>& a, int low, int high) {
        // Select a random pivot index between low and high
        int randPivot = low + rand() % (high - low + 1);
        swap(a[randPivot], a[high]); // Move chosen pivot to end
        return partition(a, low, high); // Use normal partition
    }

    // ---------------- Randomized Quick Sort ----------------
    void quickSortRand(vector<int>& a, int low, int high) {
        if (low < high) {
            int pi = randomPartition(a, low, high); // Use random pivot
            quickSortRand(a, low, pi - 1);          // Sort left subarray
            quickSortRand(a, pi + 1, high);         // Sort right subarray
        }
    }
};

//-------------------- MAIN FUNCTION --------------------
int main() {
    srand(time(0));  // Initialize random seed to get different random pivots each run

    int n;
    cout << "Enter the size of array: ";
    cin >> n;                         // Input number of elements

    vector<int> arr(n);               // Declare vector of size n
    cout << "Enter elements of the array: ";
    for (int i = 0; i < n; i++) {
        cin >> arr[i];                // Input array elements
    }

    // Copy the same array for both sorting versions
    vector<int> detArr = arr, randArr = arr;
    QuickSort qs;                     // Create QuickSort object

    // Apply both sorting techniques
    qs.quickSortDet(detArr, 0, n - 1);
    qs.quickSortRand(randArr, 0, n - 1);

    // Display results
    cout << "\nSorted array by Deterministic Quick Sort: ";
    for (int x : detArr) cout << x << " ";

    cout << "\nSorted array by Randomized Quick Sort: ";
    for (int x : randArr) cout << x << " ";

    cout << endl;
    return 0;                         // End of program
}

//input//
/*Enter the size of array: 6
Enter elements of the array: 10 7 8 9 1 5*/
//output//
//Sorted array by Deterministic Quick Sort: 1 5 7 8 9 10
//Sorted array by Randomized Quick Sort: 1 5 7 8 9 10


------------------------------------------------------------------------------------------------------------------------------------------


## ðŸ§© **Assignment Explanation**

### **DAA 5: Write a program to implement Quick Sort using deterministic and randomized strategies.**

You must:

1. Take an array from the user.
2. Sort it using:

   * **Deterministic Quick Sort** (last element as pivot)
   * **Randomized Quick Sort** (random pivot chosen)
3. Display both sorted results.

This shows the effect of **random pivot selection**, which helps reduce chances of the **worst case**.

---

## ðŸ§  **Theory (in Simple Words)**

### **What is Quick Sort?**

Quick Sort is a **divide-and-conquer sorting algorithm** that:

1. Selects a **pivot** element.
2. Divides (partitions) the array into:

   * Left side â†’ elements smaller than pivot
   * Right side â†’ elements larger than pivot
3. Recursively sorts both sides.

---

### **Types**

1. **Deterministic Quick Sort**

   * Always picks the **last element** as the pivot.
   * Simple but can lead to the **worst case** for sorted input.

2. **Randomized Quick Sort**

   * Picks a **random element** as the pivot.
   * Reduces the chance of getting worst case by randomizing input behavior.

---

### **Example**

Input:

```
5
10 7 8 9 1
```

Output:

```
Sorted array by Deterministic Quick Sort: 1 7 8 9 10
Sorted array by Randomized Quick Sort: 1 7 8 9 10
```

Both give the same sorted output â€” but **randomized quick sort** is **faster on average** for many test cases.

---

## âš™ï¸ **Step-by-Step Working**

### Example Array: `[10, 7, 8, 9, 1]`

1. Choose pivot â†’ last element (1)
2. Move smaller elements left of pivot.
3. Recursively repeat for left and right subarrays.

---

## â±ï¸ **Time and Space Complexity**

| Type                           | Case       | Complexity                                                 | Explanation |
| ------------------------------ | ---------- | ---------------------------------------------------------- | ----------- |
| **Best Case**                  | O(N log N) | When the pivot divides the array evenly.                   |             |
| **Average Case**               | O(N log N) | Expected case for most inputs.                             |             |
| **Worst Case (Deterministic)** | O(NÂ²)      | Occurs when the array is already sorted or reverse sorted. |             |
| **Worst Case (Randomized)**    | Rare       | Random pivot reduces chance of O(NÂ²).                      |             |
| **Space Complexity**           | O(log N)   | Due to recursion stack.                                    |             |

---

## ðŸ’¡ **Applications (in Simple Words)**

| Field                     | Application                                       |
| ------------------------- | ------------------------------------------------- |
| **Databases**             | Used in sorting records and query optimization.   |
| **Search Engines**        | To organize and rank large datasets efficiently.  |
| **Computer Graphics**     | Sorting coordinates or depth values in rendering. |
| **E-commerce**            | Price sorting, product recommendation order.      |
| **Programming Libraries** | STLâ€™s `sort()` in C++ uses Quick Sort variants.   |

---

## ðŸŽ¤ **Viva Questions and Answers**

**Q1. What is Quick Sort?**
A: It is a divide-and-conquer algorithm that picks a pivot, partitions the array, and recursively sorts subarrays.

**Q2. What is the difference between deterministic and randomized Quick Sort?**
A: Deterministic always picks a fixed pivot (like last element), while randomized picks a random pivot each time.

**Q3. Why is Randomized Quick Sort faster on average?**
A: Because random pivot selection avoids consistently bad pivots and prevents the worst-case scenario.

**Q4. What is the best case for Quick Sort?**
A: When the pivot divides the array evenly each time â†’ O(N log N).

**Q5. What is the worst case?**
A: When the pivot always ends up being smallest or largest element â†’ O(NÂ²).

**Q6. Is Quick Sort stable?**
A: No, itâ€™s not a stable sort because it can swap equal elements' positions.

**Q7. What is the pivot?**
A: A chosen element around which the array is partitioned.

**Q8. What is meant by partitioning in Quick Sort?**
A: It means rearranging elements so that those smaller than pivot go left and larger go right.

**Q9. What are the advantages of Quick Sort?**
A: Faster in practice, uses less memory, and widely used in systems.

**Q10. What is the average complexity of Quick Sort?**
A: O(N log N).

---

## ðŸ§¾ **Summary**

* **Quick Sort** divides the array using a **pivot** and recursively sorts subarrays.
* **Deterministic Quick Sort** uses a fixed pivot â†’ may hit worst case.
* **Randomized Quick Sort** uses random pivot â†’ better average performance.
* It is efficient and widely used in practical applications.

---

Would you like me to add a **visual step-by-step dry run (with array elements and recursion)** for N=5?
Itâ€™s great for viva explanation.
